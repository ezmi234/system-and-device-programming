System and Device Programming
Laboratory number 01 (System and Programming part)



Learning goals
--------------

Review laboratory: Using an IDE to program in C and C++, parallel
programming in C/POSIX, i.e., processes and threads.
The first exercise can be solved in any operating system in C++.
All the others are suggested for Linux and should be solved in C
(the corresponding C++ construct will be introduced in the following
weeks).
Solve all exercises or the ones more suited for you, at choice.


 
Exercise 01
Use an IDE to write a single or a multi-file project
---------------------------------------------------

Select your preferred IDE to program in C/C++ (VS Code, Microsoft
Visual Studio, CLion, etc.) and write the following C++ program to check
your ability to work with it.

The main program receives an "n" integer value on the command line.
Then, it calls three functions:
1. The first one dynamically allocates an array of size "n" of real values
   and reads the array from standard input.
2. The second sorts the array in increasing order.
3. The third function displays the sorted array on standard output.

Write, compile, and debug two versions of this project:
1. The fiurst one, include all functions in a single C++ file.
2. In the second one, insert the main and the three functions in three
   separate files.

Suggestions
-----------

1. Define the array using C-like dynamic memory allocation:
   float *vet;
   ...
   vet = (float *) malloc (n * sizeof (float));
   if (vet==nullptr) { ... error ... }

2. Uses one of the main sorting algorithms at your choice (i.e.,
   insertion sort, selection sort, quick-sort, etc.)



Exercise 02
Code analysis: fork, exec, system
---------------------------------

Given the following program, draw the process generation tree and
indicate what it displays and for what reason.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(){
  pid_t pid;
  int i;
  setbuf (stdout,0);
  for (i=1; i<=3; i++){
    switch (i) {
      case 1: fork(); break;
      case 2: pid=fork(); if (pid!=0) system ("echo case 2"); break;
      case 3: execlp ("echo", "myPgrm", "case 3", NULL); break;
    }
  }
  return (0);
} 



Exercise 03
Code analysis: fork, exec, system
---------------------------------

Given the following program, draw the process generation tree and
indicate what it displays and for what reason.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main () {
  int i;
  setbuf (stdout,0);
  for (i=0; i<2; i++) {
    printf ("i=%d\n", i);
    if (fork())             // Call # 1
      fork ();              // Call # 2
    else
      system ("echo i=i");  // Call # 3
  }
  return (1);
}



Exercise 04
Code analysis: fork, exec, system
---------------------------------

Given the following program, draw the process generation tree and
indicate what it displays and for what reason.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main () {
  int i, j=-1;

  setbuf (stdout,0);
  for (i=0; i<5; i++) {
    printf ("i=%d\n", i);
    if (!fork()) {
      for (j=2; j>0; j--) {
        fork();
        execlp ("echo", "i", "j", (char *) 0);
      }
    } else {
      printf ("j=%d \n", j);
    }
  }

  return (1);
}



Exercise 05
Code implementation with processes
----------------------------------

Write a C program that receives two integer values on the command line,
h and n, and it generates a process tree of height h and degree n.

For example, if h=3 and n=2:
- the primary process creates two processes and exits
- each one of these two processes creates two other processes and exit
- each one of these four processes creates two other processes and exit
at this point, eight processes run on the tree leaf, and the program
stops.

More in detail, each node of the tree is a process.
The initial process generates "n" child jobs and exits.
All child processes must do the same thing, causing several
processes on the tree leaves equal to "n^h".
Processes on the leaves must all display their own PID and end.


Exercise 06
Code implementation with processes
----------------------------------

A binary number of size "n" can be easily generated by a recursive
function like the one reported in file e05recursive.c

Transform the recursive program (06recursive.c) into a concurrent one,
replacing the recursive procedure with the generation of an appropriate
number of *processes*.
Each process must display one binary number.
The program can display binary numbers in any order.

For example, if n=3, the function must generate and print numbers:
000, 001, 010, 011, 100, 101, 110, 111
IN ANY ORDER.



Exercise 07
Code implementation with threads
(a variant of exercise 05 but with threads)
-------------------------------------------

Implement a C program, thread_generation, that receives a command
line parameter "n".
The parent thread creates two threads and waits for their termination.
Each further thread creates the other two threads, awaiting their
termination. 
Tread creation stops after 2^n threads have been created, i.e., the
ones that stand on the leaves of a tree with 2^n leaves.

For example, if n=3
- the main thread creates two threads
- each one of these two threads creates two other threads
- each one of these four threads creates two other threads.
  At this point, eight leaf threads are running, and the program must stop.

Each leaf thread must print its generation tree, i.e., the sequence of thread identifiers from the main thread (the tree root) to the leaf thread (the tree leaf).

The following is an example of the program execution: 

quer@quer-VirtualBox:~/current/sdp$ ./l01e05 3
140051327870720 140051311085312 140051224717056 
140051327870720 140051311085312 140051224717056 
140051327870720 140051311085312 140051233109760 
140051327870720 140051319478016 140051207931648 
140051327870720 140051311085312 140051233109760 
140051327870720 140051319478016 140051207931648 
140051327870720 140051319478016 140051216324352 
140051327870720 140051319478016 140051216324352 

In the previous example, the numbers are the thread identifiers displayed
as "long integer values".

Suggestion
----------

Instead of printing (and storing) thread identifiers (tids) as "long integer"
values, you can store and display "user thread identifiers", e.g., integer
numbers given by the user to each thread.